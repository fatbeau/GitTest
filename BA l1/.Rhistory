### When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
##This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.
add <- function(x, y) {x + y}
add <- function(x, y) {x + y}
add(2, 3)
print(x{i})
print(x[i])
}
for(i in 1:4) {
print(x[i])
for(i in 1:4) { print(x[i])}
for(i in 1:4) {print(x[i])}
print(x[i])
for(i in 1:4) {print(x[i])}
}
}
}
print(x[i])}
print(x[i])}
print(x[i])}
}
for(i in 1:4) print(x[i])
for(i in 1:4) print(x[i])
for(i in 1:4) print(x)
for(i in 1:4) print(x[1])
x <- c("a", "b", "c", "d")
x <- c("a", "b")
for(i in 1:4) print(x[i])
x <- c("a", "b", "c", "b")
for(i in 1:4) print(x[i])
add2 <- function(x, y) {x + y}
add(4, 5)
above10 <- function(x) {
use <- x > 10
x[use]
}
above10(5)
above10(23)
x <- 1:20
above10(x)
make.power <- function(n) {
pow <- function(x) {
x^n
}
pow
}
cube <- make.power(3)
square <- make.power(2)
cube(3)
suare(3)
square(3)
y <- 10
f <- function(x) {
y <- 2
y^2 + g(x)
}
g <- function(x) {
x*y
}
y <-
f(3)
y <- 10
f <- function(x) {
y <- 2
y^2 + g(x)
}
g <- function(x) {
x*y
}
f(3)
setwd("~/Desktop/TestR/BA l1")
rm(list=ls(all=TRUE))
data=read.table('table.csv', header = T,sep=',')
View(data)
str(data)
summary(data)
View(data)
testdata=data[1:2,]
testdata = scale(testdata)
testdata=data[1:2,]
str(testdata)
View(testdata)
testdata=data[1:2,2:13]
str(testdata)
View(testdata)
d = dist(testdata, method = "euclidean")
hcward = hclust(d, method="ward.D")
data$groups<-cutree(hcward,k=4)
data$groups<-cutree(hcward,k=2)
data$groups<-cutree(hcward,k=3)
data$groups<-cutree(hcward,k=2)
View(testdata)
install.packages("lattice") #install the lattice package by using the install.packages() function
library(lattice)
rm(list=ls(all=TRUE))
data=read.table('table.csv', header = T,sep=',')
View(data)
data=read.table('table.csv', header = T,sep=',')
View(data)
data=read.table('table.csv', header = T,sep=',')
View(data)
str(data)
summary(data)
# Let's plot our data to see if we can identify groups visually
plot(data$CV, data$ADS, main = "SKU Example", ylab="Average Daily Sales", xlab= "Coefficient of Variation")
abline(v=0.2, col = "red") # we can draw a vertical line by using the abline function and passing it the v argument
abline(h=4, col="red") # we can draw a horizontal line by using the abline function and passing it the h argument
text(0.15,9.7, "Horses", col = "red") # we can add some text to our plot by using the text() function, here to label the group "Horses"
text(0.65,9, "Wild Bulls", col = "blue") # and group "Wild Bulls"
text(0.8,2, "Crickets", col = "green") # and group "Crickets"
plot(data$Expense, data$Income, main = "SKU Example", ylab="Average Daily Sales", xlab= "Coefficient of Variation")
plot(data$Expense, data$Income, main = "IS", ylab="Monthly Exp", xlab= "Monthly Inc")
plot(data$Expense, data$Income, main = "IS", ylab="Monthly Inc", xlab= "Monthly Exp")
testdata=data
testdata = scale(testdata)
d = dist(testdata, method = "euclidean")
hcward = hclust(d, method="ward.D")
data$groups<-cutree(hcward,k=4)
install.packages("lattice") #install the lattice package by using the install.packages() function
library(lattice) # load the lattice package by using the library() function and passing it the name of the package you wish to load
xyplot(Expense~ Income,main = "After Clustering", type="p",group=groups,data=data, # define the groups to be differentiated
auto.key=list(title="Group", space = "left", cex=1.0, just = 0.95)
install.packages("lattice")
data$groups
adddata = aggregate(.~ groups, data=data, FUN=mean)
adddata
data$groups<-cutree(hcward,k=2) # assign our points to our k=3 clusters
adddata = aggregate(.~ groups, data=data, FUN=mean)
adddata
proptemp=aggregate(Expense~ groups, data=data, FUN=length) # we create a variable called proptemp which computes the number of observations in each group (using the S variable, but you can take any.)
aggdata$proportion=(proptemp$Expense)/sum(proptemp$Expense) # proportion of observations in each group we compute the ratio between proptemp and the total number of observations
aggdata=aggdata[order(aggdata$proportion,decreasing=T),]
proptemp=aggregate(Expense~ groups, data=data, FUN=length)
proptemp
aggdata$proportion=(proptemp$Expense)/sum(proptemp$Expense)
aggdat$proportion=(proptemp$Expense)/sum(proptemp$Expense)
rm(list=ls(all=TRUE))
data=read.table('table.csv', header = T,sep=',')
str(data) # The str() function shows the structure of your dataset and details the type of variables that it contains
summary(data)
testdata=data# To keep our dataset safe, let's create a copy of it called "testdata"# The str() function shows the structure of your dataset and details the type of variables that it contains
testdata = scale(testdata)
d = dist(testdata, method = "euclidean") # the dist() function computes the distances of all the observations in our dataset
hcward = hclust(d, method="ward.D")
data$groups<-cutree(hcward,k=4) # assign our points to our k=3 clusters
adddata = aggregate(.~ groups, data=data, FUN=mean)
proptemp=aggregate(Expense~ groups, data=data, FUN=length)
aggdata$proportion=(proptemp$Expense)/sum(proptemp$Expense)
adddata
proptemp$Expense
(proptemp$Expense)/sum(proptemp$Expense)
a=(proptemp$Expense)/sum(proptemp$Expense)
a=a[order(aggdata$proportion,decreasing=T),]
a=a[order(a$proportion,decreasing=T),]
rm(list=ls(all=TRUE))
data=read.table('table.csv', header = T,sep=',')
View(data)
str(data) # The str() function shows the structure of your dataset and details the type of variables that it contains
summary(data)
rm(list=ls(all=TRUE))
data=read.table('table.csv', header = T,sep=',')
str(data) # The str() function shows the structure of your dataset and details the type of variables that it contains
summary(data)
plot(data$Ex, data$In, main = "SKU Example", ylab="Average Daily Sales", xlab= "Coefficient of Variation")
testdata=data
testdata = scale(testdata)
View(testdata)
d = dist(testdata, method = "euclidean")
hcward = hclust(d, method="ward.D")
data$groups<-cutree(hcward,k=3)
data$groups<-cutree(hcward,k=4)
aggdata = aggregate(.~ groups, data=data, FUN=mean)
aggdata
proptemp=aggregate(Ex~ groups, data=data, FUN=length)
proptemp
aggdata$proportion=(proptemp$Ex)/sum(proptemp$Ex)
aggdata=aggdata[order(aggdata$proportion,decreasing=T),]
aggdata
install.packages("lattice") #install the lattice package by using the install.packages() function
library(lattice) # load the lattice package by using the library() function and passing it the name of the package you wish to load
xyplot(Ex~ In,main = "After Clustering", type="p",group=groups,data=data, # define the groups to be differentiated
auto.key=list(title="Group", space = "left", cex=1.0, just = 0.95), # to produce the legend we use the auto.key= list()
par.settings = list(superpose.line=list(pch = 0:18, cex=1)), # the par.settings argument allows us to pass a list of display settings
col=c('blue','green','red', 'pink'))
data$groups<-cutree(hcward,k=3) # assign our points to our k=3 clusters
aggdata = aggregate(.~ groups, data=data, FUN=mean) # The aggregate() function presents a summary of a statistic, broken down by one or more groups. Here we compute the mean of each variable for each group.
aggdata
# One thing we would like to have is the proportion of our data that is in each cluster
proptemp=aggregate(Ex~ groups, data=data, FUN=length) # we create a variable called proptemp which computes the number of observations in each group (using the S variable, but you can take any.)
proptemp
aggdata$proportion=(proptemp$Ex)/sum(proptemp$Ex) # proportion of observations in each group we compute the ratio between proptemp and the total number of observations
aggdata=aggdata[order(aggdata$proportion,decreasing=T),]
aggdata
# The lattice library provides a complete set of functions for producing advanced plots.
install.packages("lattice") #install the lattice package by using the install.packages() function
library(lattice) # load the lattice package by using the library() function and passing it the name of the package you wish to load
xyplot(Ex~ In,main = "After Clustering", type="p",group=groups,data=data, # define the groups to be differentiated
auto.key=list(title="Group", space = "left", cex=1.0, just = 0.95), # to produce the legend we use the auto.key= list()
par.settings = list(superpose.line=list(pch = 0:18, cex=1)), # the par.settings argument allows us to pass a list of display settings
col=c('blue','green','red'))
install.packages("lattice")
rm(list=ls(all=TRUE))
data=read.table('table.csv', header = T,sep=',') # The function read.table enables us to read flat files such as .csv files
# Now let's have a look at our variables and see some summary statistics
str(data) # The str() function shows the structure of your dataset and details the type of variables that it contains
summary(data) # The summary() function provides for each variable in your dataset the minimum, mean, maximum and quartiles
# Let's plot our data to see if we can identify groups visually
plot(data$Ex, data$In, main = "SKU Example", ylab="Average Daily Sales", xlab= "Coefficient of Variation")
testdata=data  # To keep our dataset safe, let's create a copy of it called "testdata"
testdata = scale(testdata) # To keep our dataset safe, let's create a copy of it called "testdata"
d = dist(testdata, method = "euclidean") # the dist() function computes the distances of all the observations in our dataset
hcward = hclust(d, method="ward.D") # hclust() function performs hiearchical clustering, we pass it the distances, and we set the method argument to "ward.D"
data$groups<-cutree(hcward,k=4) # assign our points to our k=3 clusters
aggdata = aggregate(.~ groups, data=data, FUN=mean) # The aggregate() function presents a summary of a statistic, broken down by one or more groups. Here we compute the mean of each variable for each group.
aggdata
# One thing we would like to have is the proportion of our data that is in each cluster
proptemp=aggregate(Ex~ groups, data=data, FUN=length) # we create a variable called proptemp which computes the number of observations in each group (using the S variable, but you can take any.)
proptemp
aggdata$proportion=(proptemp$Ex)/sum(proptemp$Ex) # proportion of observations in each group we compute the ratio between proptemp and the total number of observations
aggdata=aggdata[order(aggdata$proportion,decreasing=T),]
aggdata
# The lattice library provides a complete set of functions for producing advanced plots.
install.packages("lattice") #install the lattice package by using the install.packages() function
library(lattice) # load the lattice package by using the library() function and passing it the name of the package you wish to load
xyplot(Ex~ In,main = "After Clustering", type="p",group=groups,data=data, # define the groups to be differentiated
auto.key=list(title="Group", space = "left", cex=1.0, just = 0.95), # to produce the legend we use the auto.key= list()
par.settings = list(superpose.line=list(pch = 0:18, cex=1)), # the par.settings argument allows us to pass a list of display settings
col=c('blue','green','red', 'black'))
